Up until now, we talked about traditional server-side session management mechanisms.
The server stores the session object, and a session cookie is used to send the session identifier back and forth.
This session management mechanism works quite well for the majority of applications.
But when you start deploying an application on a large scale, things become a bit more complicated.
Think about what would happen when an application is replicated on many servers.
The first request goes to a particular server, and that server creates a session object and returns a session identifier.
But what happens with the second request?
That request now contains an identifier that points to a session object generated by the first server.
Several strategies to tackle this problem exist.
One example is the use of sticky sessions, where all requests within a session go to the same server.
Another example is sharing session state between servers.
But there is also another way.
Many modern applications are moving from server-side session management to client-side session management.
In this new paradigm, session state is stored on the client instead of the server.
This way, the server no longer needs to keep track of session data.
This fits well within the recent move towards stateless API-based systems.
Let’s take a look at how this works in practice.
When the user first opens the application, there is no session.
So when the server receives the first request, it generates a new session object.
The server sends this entire session object back to the browser.
From now on, every request from the browser to the server will include this session object.
The server can directly use the provided session object to access the data.
For example, when the user logs in to the application, the session object is updated.
It now contains the user’s authenticated state, as well as the user's account information.
The information stored in the session object is crucial for making authorization decisions throughout the application.
This scenario may sound familiar.
In fact, it is almost the same than the scenario for server-side session management.
The only difference is that browser now stores the session object, instead of the session identifier.
Going into the technicalities of implementing client-side session management would take us too far.
Instead, we will investigate how the move to client-side session management impacts security.
The most significant difference between the two paradigms is the locality of the session object.
One is stored on the server, while the other one is stored on the client.
The implications of this move are significant.
The session object stored on the server is considered trusted data.
There is no way for the attacker to manipulate the contents of the object directly.
However, with a session object stored on the client, that assumption no longer holds.
The attacker can now change a session object before sending it to the application.
Therefore, the data stored in the session object can no longer be trusted.
The server should check the integrity of the session object, before using any of its data.
This integrity check is often implemented by adding a server-generated signature to the session object.
The second difference between these two paradigms is the level of control over active sessions.
With server-side sessions, it is straightforward to consult a list of active sessions or to revoke a specific session.
With client-side sessions, this is a lot harder, or even impossible.
There is no easy way to list active sessions, because these sessions are only seen when the client makes a request.
Revoking a specific session is also a hard problem, that is still being debated by experts in the field.
A final important difference to be aware of follows from the implementation of a client-side session management mechanism.
Many applications moved away from using cookies, and use custom headers to transport the session object.
While this avoids some of the security challenges with cookies, it also complicates matters for the developer.
Cookies are handled automatically by the browser, while custom headers are not.
So with custom headers, the developer needs to retrieve the session object from the server,
store it somewhere, and attach it to outgoing requests.
The choices made to implement these operations have certain ramifications for security.
If you want to know more about client-side session management mechanisms,
take a look at the references at the end of this chapter.
What you should remember from this part is that client-side sessions have their own set of challenges and security trade-offs.
Client-side sessions are often advocated because they push a part of the load from the server to the client.
However, server-side session management is a lot simpler to get right.
And to be honest, it is more than sufficient for most applications.