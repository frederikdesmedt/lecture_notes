In the previous part, we elaborated on various insecure password storage strategies.
The best scenario we covered so far was salting and hashing.
And even then, an attacker could brute force the password at a rate of billions of hashes per second.
Brute forcing is so effective because hashing algorithms are designed to be fast.
In essence, hashing algorithms are well-suited for other purposes, but not for storing passwords.
So, how do you store a password in a secure way?
To prevent brute force attacks, you should use a dedicated password hashing function.
These are cryptographic functions that perform a certain amount of iterations to calculate the output.
As a result, they are expensive to execute, and withstand brute force attacks by design.
In practice, all recommended password hashing functions also use a salt.
The salt ensures that even if two users pick the same password, the hash will be different.
Let's take a look at an example of such a function.
Here, you can see the hash generated by "bcrypt", a popular password hashing function.
If you analyze the output, you can identify different sections.
The first part indicates which algorithm has generated the hash.
The second part specifies a cost parameter.
This parameter is configurable and makes the function more expensive to execute.
The third part contains a salt and the resulting hash.
This output is stored in the database.
Note how it contains everything needed to verify a password during authentication.
"bcrypt" is the most popular example of a password hashing function.
Three other functions are "argon2", "PBKDF2" and "scrypt".
All functions have similar security properties, but language support may differ.
Before we take a look at a code example, let's revisit the brute forcing numbers from the previous part.
We covered that a cracking rig with 8 NVIDIA GTX cards could calculate billions of MD5 and SHA1 hashes per second.
How do you think "bcrypt" holds up against these hashing algorithms?
For a cost factor of 5, the machine can only calculate 100 000 hashes per second.
That is a huge difference.
Note that the cost factor is exponential and that the current recommendations list 12 as a minimum.
So the numbers of hashes per second with a cost factor of 12 will be drastically lower.
As you can see, the use of a password hashing function prevents the mass-recovery of passwords.
If the attacker obtains the hashes, it may be feasible to crack a few passwords selectively.
But cracking millions of passwords is out of the question.
All that said, how do you implement the use of such a password hashing function in your application?
Here, you see a code example of calculating a "bcrypt" hash.
This is the code your application executes when the user first configures a password.
The output of calling the function is stored in the database for later use.
When the user authenticates, your application needs to verify the password.
As you can see here, the "bcrypt" library offers a method to do that.
All it needs as input is the submitted password and the hash from the database.
It returns true if the password is valid, and false otherwise.
In essence, the correct use of a password hashing function is not harder than salting and hashing.
Starting to use a password hashing function is trivial in a new project.
But what about an existing application that stores passwords in an insecure way?
There are a few strategies you can follow to upgrade the storage mechanism.
The first strategy offers a gradual upgrade path.
The upgrade takes place during authentication.
When the user has provided a valid password, the application checks how the password is stored in the database.
When the stored hash is calculated with a legacy algorithm, it needs to be updated.
The application uses the password to calculate a "bcrypt" hash, and stores the new hash in the database.
Running this gradual upgrade strategy for a couple of months will replace the stored hashes for all your active users.
At a certain point in time, it makes sense to reset the passwords on all accounts that have not yet been upgraded.
If users want to resume their account, they can use the account recovery process.
The second strategy is a bit more drastic, as it upgrades all stored passwords in one go.
Imagine that you have a database full of unsalted MD5 hashes.
If you want to upgrade your application to "bcrypt", you can use the MD5 hashes as input for the "bcrypt" function.
The database now contains "bcrypt" hashes of MD5 hashes of the plaintext password.
The code for the authentication procedure now follows these steps.
First, it checks the validity of the provided password by double hashing it.
Next, it uses the plaintext password to calculate a single "bcrypt" hash
and replaces the double hash with the newly generated one.
Note that in this scenario, you need to keep track of which accounts still use the double hash,
and which ones use the normal "bcrypt" hash.
As you can see, there are plenty of options to store passwords securely.
The current best practice is to use a password hashing function with a reasonable cost factor.
One practical recommendation is "bcrypt" with a cost factor of 12.