I can imagine that the chapter about preventing unauthorized access had a couple of surprises. The implementation of proper authorization in web applications is not an easy task. As we have seen, authorization is connected to authentication and session management. Unfortunately, the loose coupling in web applications causes quite a few headaches.
Most applications today still authenticate users with a username and password. To be honest, this is not likely to change anytime soon. But as we have seen, a password can work quite well, if handled correctly. The use of a password manager can be a real game changer here.
Your application also needs to take extra care to handle passwords. Many applications secure passwords in an insecure way. And as we have seen, in the modern era of data breaches, this leads to all kinds of mayhem. 
Of course, you should aim to prevent data breaches altogether. But you need a layered defense, in case the worst case scenario becomes a reality. Here, this means storing passwords in the database in a secure way. The current best practice is using a dedicated password hashing mechanism, with a reasonable cost factor. One example is bcrypt, with a cost factor of 12.
Unfortunately, storing passwords is only part of the puzzle. Regardless of the storage mechanism, your application can also be vulnerable to brute force attacks. Blindly guessing username/password combinations is not an effective strategy. That is why an attacker will abuse an enumeration flaw to construct a list of valid usernames. With that list, a brute force authentication attack can become quite effective.
We talked a lot about dealing with passwords. But make no mistake, passwords alone remain a weak form of authentication. By deploying multi-factor authentication, you combine a password with another authentication factor. Well-known examples are security tokens, smartcards or USB security keys. And if you do not feel like implementing this yourself, you can always consider outsourcing authentication. Social login mechanisms allow you to delegate authentication to a third-party provider. Of course, doing so requires attention to other security details.
But let's go back to authorization. As you know now, authentication is a prerequisite for authorization. But by default, authentication information is not propagated on future requests. For this purpose, web applications depend on a session management mechanism.
Most web applications depend on server-side session management with cookies. The browser receives a cookie containing a session identifier. It will attach this cookie on all outgoing requests to the application. As you can imagine, this cookie is quite valuable and needs to be adequately protected.
One major threat against session management is session hijacking. We have covered network-based and script-based session hijacking attacks. Defending against these attacks requires tightening of the cookie security properties. We have seen how to do this with the Secure and HttpOnly flag. But for these flags to have any effect, you need to enable them in your application explicitly.
At the end of the chapter, we zoomed in on authorization itself. We talked with Maarten Decat about getting authorization right in your application. We also covered two practical attacks and their defenses. One attack was Cross-Site Request Forgery (CSRF), where the attacker can trick the victim's browser into making requests. A CSRF attack allows the attacker to perform operations in the user's name. The second attack abused insecure direct object references. In this attack, the attacker can gain direct access to an object through its identifier.
Both attacks are not hard to defend against. However, if you are not aware of these attacks, the chances are that mitigations are missing in your application.

Overview of best practices
Condensing an entire chapter into a concise list of best practices not that easy. Nonetheless, below is a set of practices to prevent unauthorized access to your applications.
Use a dedicated password hashing mechanism to store passwords in a secure way
Ensure your application does not leak information about existing accounts 
Offer two-factor authentication, but stay clear of SMS-based verification codes
Add the Secure cookie flag to all cookies, and the HttpOnly flag where relevant
Implement proper CSRF defenses
Check every entry point of your application to see if it contains appropriate authorization checks